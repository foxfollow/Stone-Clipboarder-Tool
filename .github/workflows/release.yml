name: Build and Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:

permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  build:
    runs-on: macos-15

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Validate secrets
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
        run: |
          if [ -z "$SPARKLE_PRIVATE_KEY" ]; then
            echo "ERROR: SPARKLE_PRIVATE_KEY secret is required but not set"
            echo "Please add your Sparkle private key as a repository secret"
            exit 1
          fi
          echo "All required secrets are present"

      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: "16.0"

      - name: Install Sparkle tools
        run: |
          brew install --cask sparkle
          echo "Sparkle installation completed"

      - name: Find and setup Sparkle
        id: sparkle
        run: |
          # Find Sparkle installation
          SIGN_UPDATE_PATH=""
          
          # Check common locations
          for sparkle_dir in /opt/homebrew/Caskroom/sparkle/*/bin /usr/local/Caskroom/sparkle/*/bin; do
            if [ -f "$sparkle_dir/sign_update" ]; then
              SIGN_UPDATE_PATH="$sparkle_dir/sign_update"
              echo "Found sign_update at: $SIGN_UPDATE_PATH"
              
              # Remove macOS quarantine attribute to avoid Gatekeeper issues
              xattr -d com.apple.quarantine "$SIGN_UPDATE_PATH" 2>/dev/null || echo "No quarantine attribute to remove"
              chmod +x "$SIGN_UPDATE_PATH"
              break
            fi
          done
          
          if [ -z "$SIGN_UPDATE_PATH" ]; then
            echo "ERROR: sign_update tool not found"
            exit 1
          fi
          
          echo "SIGN_UPDATE_PATH=$SIGN_UPDATE_PATH" >> $GITHUB_OUTPUT
          echo "sign_update_path=$SIGN_UPDATE_PATH" >> $GITHUB_ENV

      - name: List schemes
        run: |
          xcodebuild -project StoneClipboarderTool.xcodeproj -list

      - name: Build app
        run: |
          echo "Starting build process..."
          xcodebuild -project StoneClipboarderTool.xcodeproj \
            -scheme StoneClipboarderTool \
            -configuration Release \
            -derivedDataPath build \
            -destination "platform=macOS" \
            -allowProvisioningUpdates \
            MACOSX_DEPLOYMENT_TARGET=15.0 \
            CODE_SIGN_IDENTITY="" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO \
            ONLY_ACTIVE_ARCH=NO \
            | tee build.log
          echo "Build completed"

      - name: Verify build
        run: |
          echo "Checking build output..."
          ls -la build/Build/Products/Release/ || echo "Release folder not found"

          if [ ! -d "build/Build/Products/Release/StoneClipboarderTool.app" ]; then
            echo "Build failed - app not found"
            echo "Build log:"
            cat build.log || echo "No build log found"
            echo "Checking all build products:"
            find build/ -name "*.app" -type d 2>/dev/null || echo "No .app bundles found"
            exit 1
          fi
          echo "App built successfully at: build/Build/Products/Release/StoneClipboarderTool.app"
          ls -la "build/Build/Products/Release/StoneClipboarderTool.app"

      - name: Create app bundle
        run: |
          mkdir -p release
          cp -r build/Build/Products/Release/StoneClipboarderTool.app release/
          ls -la release/

      - name: Create ZIP and handle signing
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
        run: |
          cd release
          zip -r StoneClipboarderTool.zip StoneClipboarderTool.app
          
          echo "ZIP created successfully"
          ls -la StoneClipboarderTool.zip
          
          # Try to sign if private key is available
          if [ -n "$SPARKLE_PRIVATE_KEY" ]; then
            echo "Attempting to sign update..."
            
            # Create private key file
            echo "$SPARKLE_PRIVATE_KEY" > ../private_key.pem
            chmod 600 ../private_key.pem
            
            # Use the dynamically found path
            SIGN_UPDATE="${{ env.sign_update_path }}"
            echo "Using sign_update at: $SIGN_UPDATE"
            
            if [ -f "$SIGN_UPDATE" ] && [ -x "$SIGN_UPDATE" ]; then
              # Try signing with different approaches
              echo "Method 1: --ed-key-file with file"
              SIGNATURE=$("$SIGN_UPDATE" --ed-key-file ../private_key.pem StoneClipboarderTool.zip 2>&1) || true
              
              if echo "$SIGNATURE" | grep -q "ERROR"; then
                echo "Method 1 failed: $SIGNATURE"
                
                echo "Method 2: --ed-key-file with stdin"
                SIGNATURE=$(cat ../private_key.pem | "$SIGN_UPDATE" --ed-key-file - StoneClipboarderTool.zip 2>&1) || true
                
                if echo "$SIGNATURE" | grep -q "ERROR"; then
                  echo "Method 2 failed: $SIGNATURE"
                  
                  echo "Method 3: Raw key from PKCS8"
                  RAW_KEY=$(grep -v "PRIVATE KEY" ../private_key.pem | tr -d '\n')
                  SIGNATURE=$(echo "$RAW_KEY" | "$SIGN_UPDATE" --ed-key-file - StoneClipboarderTool.zip 2>&1) || true
                  
                  if echo "$SIGNATURE" | grep -q "ERROR"; then
                    echo "All signing methods failed. Proceeding without signature."
                    echo "Error: $SIGNATURE"
                    SIGNATURE="UNSIGNED_BUILD"
                  fi
                fi
              fi
              
              # Extract signature if successful
              if ! echo "$SIGNATURE" | grep -q "ERROR" && ! echo "$SIGNATURE" | grep -q "UNSIGNED"; then
                if echo "$SIGNATURE" | grep -q "sparkle:edSignature="; then
                  SIGNATURE=$(echo "$SIGNATURE" | grep -o 'sparkle:edSignature="[^"]*"' | cut -d'"' -f2)
                elif echo "$SIGNATURE" | grep -q "="; then
                  SIGNATURE=$(echo "$SIGNATURE" | grep -o '[A-Za-z0-9+/]\+=' | head -1)
                fi
                echo "Successfully generated signature: $SIGNATURE"
              fi
            else
              echo "sign_update tool not found or not executable"
              SIGNATURE="UNSIGNED_BUILD"
            fi
            
            # Clean up private key
            rm -f ../private_key.pem
          else
            echo "No private key provided - creating unsigned build"
            SIGNATURE="UNSIGNED_BUILD"
          fi
          
          echo "SPARKLE_SIGNATURE=$SIGNATURE" >> $GITHUB_ENV
          echo "Final signature: $SIGNATURE"

      - name: Get version
        id: version
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Processing version: $VERSION"

      - name: Update appcast
        run: |
          SIZE=$(stat -f%z release/StoneClipboarderTool.zip)
          DATE=$(date -u +"%a, %d %b %Y %H:%M:%S %z")
          REPO_OWNER="${{ github.repository_owner }}"
          REPO_NAME="${{ github.event.repository.name }}"

          echo "File size: $SIZE bytes"
          echo "Date: $DATE"
          echo "Version: $VERSION"
          echo "Signature: $SPARKLE_SIGNATURE"
          echo "Repository: $REPO_OWNER/$REPO_NAME"

          # Backup original appcast
          cp docs/appcast.xml docs/appcast.xml.backup

          # Update appcast with new values using our placeholders
          sed -i '' "s|REPO_OWNER|$REPO_OWNER|g" docs/appcast.xml
          sed -i '' "s|REPO_NAME|$REPO_NAME|g" docs/appcast.xml
          sed -i '' "s|VERSION_NUMBER|$VERSION|g" docs/appcast.xml
          sed -i '' "s|SIGNATURE_PLACEHOLDER|$SPARKLE_SIGNATURE|g" docs/appcast.xml
          sed -i '' "s|FILE_SIZE|$SIZE|g" docs/appcast.xml
          sed -i '' "s|RELEASE_DATE|$DATE|g" docs/appcast.xml

          echo "Updated appcast.xml:"
          cat docs/appcast.xml

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          files: release/StoneClipboarderTool.zip
          tag_name: v${{ steps.version.outputs.version }}
          name: Release ${{ steps.version.outputs.version }}
          draft: false
          prerelease: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./docs
          force_orphan: true
