name: Build and Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:

permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  build:
    runs-on: macos-15
    environment: release

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: "16.0"

      - name: Install Sparkle tools
        run: |
          brew install --cask sparkle
          echo "Sparkle installation completed"

          # List all Sparkle installations
          find /opt/homebrew/Caskroom -name "*sparkle*" -type d 2>/dev/null || true
          find /usr/local/Caskroom -name "*sparkle*" -type d 2>/dev/null || true

      - name: Verify Sparkle installation
        run: |
          SPARKLE_PATH="/opt/homebrew/Caskroom/sparkle"
          echo "Checking Sparkle installation at: $SPARKLE_PATH"
          ls -la "$SPARKLE_PATH" || echo "Sparkle not found at expected path"

          # Check multiple possible locations
          for sparkle_dir in /opt/homebrew/Caskroom/sparkle/*/bin /usr/local/Caskroom/sparkle/*/bin; do
            if [ -d "$sparkle_dir" ]; then
              echo "Found Sparkle bin directory: $sparkle_dir"
              ls -la "$sparkle_dir"
              if [ -f "$sparkle_dir/sign_update" ]; then
                echo "Found sign_update at: $sparkle_dir/sign_update"
                chmod +x "$sparkle_dir/sign_update"
              fi
            fi
          done

      - name: List schemes
        run: |
          xcodebuild -project StoneClipboarderTool.xcodeproj -list

      - name: Build app
        run: |
          echo "Starting build process..."
          xcodebuild -project StoneClipboarderTool.xcodeproj \
            -scheme StoneClipboarderTool \
            -configuration Release \
            -derivedDataPath build \
            -destination "platform=macOS" \
            -allowProvisioningUpdates \
            MACOSX_DEPLOYMENT_TARGET=15.0 \
            CODE_SIGN_IDENTITY="" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO \
            ONLY_ACTIVE_ARCH=NO \
            | tee build.log
          echo "Build completed"

      - name: Verify build
        run: |
          echo "Checking build output..."
          ls -la build/Build/Products/Release/ || echo "Release folder not found"

          if [ ! -d "build/Build/Products/Release/StoneClipboarderTool.app" ]; then
            echo "Build failed - app not found"
            echo "Build log:"
            cat build.log || echo "No build log found"
            echo "Checking all build products:"
            find build/ -name "*.app" -type d 2>/dev/null || echo "No .app bundles found"
            exit 1
          fi
          echo "App built successfully at: build/Build/Products/Release/StoneClipboarderTool.app"
          ls -la "build/Build/Products/Release/StoneClipboarderTool.app"

      - name: Create app bundle
        run: |
          mkdir -p release
          cp -r build/Build/Products/Release/StoneClipboarderTool.app release/
          ls -la release/

      - name: Sign update
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
        run: |
          if [ -z "$SPARKLE_PRIVATE_KEY" ]; then
            echo "SPARKLE_PRIVATE_KEY secret not found"
            exit 1
          fi

          echo "$SPARKLE_PRIVATE_KEY" > private_key.pem
          chmod 600 private_key.pem

          echo "Debugging private key..."
          echo "Key file size: $(wc -c < private_key.pem) bytes"
          echo "Key first line: $(head -1 private_key.pem)"
          echo "Key last line: $(tail -1 private_key.pem)"

          echo "Validating private key format..."
          if ! openssl pkey -in private_key.pem -noout 2>/dev/null; then
            echo "OpenSSL validation failed, trying to regenerate key in correct format..."
            # Try to convert the key to the right format
            if openssl pkey -in private_key.pem -out private_key_fixed.pem 2>/dev/null; then
              mv private_key_fixed.pem private_key.pem
              echo "Key format fixed"
            else
              echo "Key format cannot be fixed"
              echo "Raw key content:"
              cat private_key.pem
              exit 1
            fi
          else
            echo "Private key validation successful"
          fi

          cd release
          zip -r StoneClipboarderTool.zip StoneClipboarderTool.app

          # Find sign_update tool with expanded search
          SIGN_UPDATE_PATH=""

          # Try multiple locations
          for base_path in /opt/homebrew /usr/local; do
            for sparkle_path in "$base_path"/Caskroom/sparkle/*/bin/sign_update "$base_path"/bin/sign_update; do
              if [ -f "$sparkle_path" ] && [ -x "$sparkle_path" ]; then
                SIGN_UPDATE_PATH="$sparkle_path"
                echo "Found sign_update at: $SIGN_UPDATE_PATH"
                break 2
              fi
            done
          done

          # Also try which command
          if [ -z "$SIGN_UPDATE_PATH" ]; then
            WHICH_RESULT=$(which sign_update 2>/dev/null || true)
            if [ -n "$WHICH_RESULT" ] && [ -f "$WHICH_RESULT" ]; then
              SIGN_UPDATE_PATH="$WHICH_RESULT"
              echo "Found sign_update via which: $SIGN_UPDATE_PATH"
            fi
          fi

          if [ -z "$SIGN_UPDATE_PATH" ]; then
            echo "ERROR: sign_update tool not found!"
            echo "Checking all possible locations:"
            find /opt/homebrew -name "sign_update" -type f 2>/dev/null || true
            find /usr/local -name "sign_update" -type f 2>/dev/null || true
            echo "Available Sparkle directories:"
            find /opt/homebrew/Caskroom -name "*sparkle*" -type d 2>/dev/null || true
            exit 1
          fi

          echo "Using sign_update: $SIGN_UPDATE_PATH"
          echo "Testing sign_update executable:"
          "$SIGN_UPDATE_PATH" --help 2>&1 || true

          # Try to generate keys with Sparkle tools if our key doesn't work
          SPARKLE_GENERATE_KEYS=$(dirname "$SIGN_UPDATE_PATH")/generate_keys
          if [ -x "$SPARKLE_GENERATE_KEYS" ]; then
            echo "Found Sparkle generate_keys tool: $SPARKLE_GENERATE_KEYS"
          fi

          echo "Signing update (method 1: stdin with -f -)..."
          SIGNATURE=$(cat ../private_key.pem | "$SIGN_UPDATE_PATH" -f - StoneClipboarderTool.zip 2>&1)
          SIGN_EXIT_CODE=$?

          if [ $SIGN_EXIT_CODE -ne 0 ]; then
            echo "Method 1 failed with output: $SIGNATURE"
            if [ -x "$SPARKLE_GENERATE_KEYS" ]; then
              echo "Regenerating keys with Sparkle tools..."
              cd ..
              rm -f sparkle_new_private.pem sparkle_new_public.pem
              "$SPARKLE_GENERATE_KEYS" -p sparkle_new_public.pem -f sparkle_new_private.pem 2>&1 || true
              if [ -f sparkle_new_private.pem ]; then
                echo "Using newly generated Sparkle key"
                cp sparkle_new_private.pem private_key.pem
                cd release
                SIGNATURE=$(cat ../private_key.pem | "$SIGN_UPDATE_PATH" -f - StoneClipboarderTool.zip 2>&1)
                SIGN_EXIT_CODE=$?
              else
                cd release
                echo "Sparkle key generation failed, trying method 2..."
                SIGNATURE=$("$SIGN_UPDATE_PATH" -f ../private_key.pem StoneClipboarderTool.zip 2>&1)
                SIGN_EXIT_CODE=$?
              fi
            else
              echo "Method 1 failed, trying method 2 (--ed-key-file)..."
              SIGNATURE=$("$SIGN_UPDATE_PATH" -f ../private_key.pem StoneClipboarderTool.zip 2>&1)
              SIGN_EXIT_CODE=$?
            fi
          fi

          if [ $SIGN_EXIT_CODE -ne 0 ]; then
            echo "Method 2 failed, trying method 3 (print signature only)..."
            SIGNATURE=$(cat ../private_key.pem | "$SIGN_UPDATE_PATH" -f - -p StoneClipboarderTool.zip 2>&1)
            SIGN_EXIT_CODE=$?
          fi

          if [ $SIGN_EXIT_CODE -ne 0 ]; then
            echo "ERROR: All signing methods failed with exit code: $SIGN_EXIT_CODE"
            echo "Final sign output: $SIGNATURE"
            echo "Zip file info:"
            ls -la StoneClipboarderTool.zip
            echo "Private key info:"
            ls -la ../private_key.pem
            echo "Private key content (first line):"
            head -1 ../private_key.pem
            exit 1
          fi

          echo "SPARKLE_SIGNATURE=$SIGNATURE" >> $GITHUB_ENV
          echo "Generated signature: $SIGNATURE"

          rm ../private_key.pem

      - name: Get version
        id: version
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Processing version: $VERSION"

      - name: Update appcast
        run: |
          SIZE=$(stat -f%z release/StoneClipboarderTool.zip)
          DATE=$(date -u +"%a, %d %b %Y %H:%M:%S %z")

          echo "File size: $SIZE bytes"
          echo "Date: $DATE"
          echo "Signature: $SPARKLE_SIGNATURE"

          cp docs/appcast.xml docs/appcast.xml.backup

          sed -i '' "s/SIGNATURE_WILL_BE_GENERATED/$SPARKLE_SIGNATURE/g" docs/appcast.xml
          sed -i '' "s/foxfollow/${{ github.repository_owner }}/g" docs/appcast.xml
          sed -i '' "s/1\.0\.0/$VERSION/g" docs/appcast.xml
          sed -i '' "s/length=\"0\"/length=\"$SIZE\"/g" docs/appcast.xml
          sed -i '' "s/Mon, 08 Aug 2025 12:00:00 +0000/$DATE/g" docs/appcast.xml

          echo "Updated appcast.xml:"
          cat docs/appcast.xml

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          files: release/StoneClipboarderTool.zip
          tag_name: v${{ steps.version.outputs.version }}
          name: Release ${{ steps.version.outputs.version }}
          draft: false
          prerelease: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./docs
          force_orphan: true
