# =============================================================================
# Build and Release Workflow for Unsigned macOS App with Sparkle Updates
# =============================================================================
#
# This workflow builds a macOS app WITHOUT Apple Developer ID subscription.
# Uses macOS 26 Tahoe runner with Xcode 26.1.1 (latest stable).
# The app uses ad-hoc code signing to minimize Gatekeeper friction.
# Users can open the app via:
#   1. Right-click â†’ Open (easiest)
#   2. Terminal: xattr -cr /Applications/YourApp.app
#
# Sparkle EdDSA signatures are used for secure auto-updates.
# =============================================================================

name: Build and Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      version:
        description: "Version number (without v prefix)"
        required: false
        default: ""

permissions:
  contents: write

env:
  APP_NAME: StoneClipboarderTool
  SCHEME: StoneClipboarderTool
  PROJECT: StoneClipboarderTool.xcodeproj

jobs:
  build:
    name: Build and Release
    runs-on: macos-26 # macOS 26 Tahoe with Xcode 26.1.1

    steps:
      # =========================================================================
      # SETUP
      # =========================================================================

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history for version detection

      - name: Determine version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ inputs.version }}" ]]; then
            VERSION="${{ inputs.version }}"
          elif [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            VERSION="${GITHUB_REF#refs/tags/v}"
          else
            VERSION="0.0.0-dev"
          fi

          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Building version: $VERSION"

      - name: Validate required secrets
        run: |
          if [[ -z "${{ secrets.SPARKLE_PRIVATE_KEY }}" ]]; then
            echo "âŒ ERROR: SPARKLE_PRIVATE_KEY secret is required"
            echo ""
            echo "Generate a new key pair with:"
            echo "  ./bin/generate_keys (from Sparkle tools)"
            echo ""
            echo "Add the PRIVATE key to GitHub Secrets as SPARKLE_PRIVATE_KEY"
            echo "Add the PUBLIC key to your app's Info.plist as SUPublicEDKey"
            exit 1
          fi
          echo "âœ… Required secrets are configured"

      - name: Setup Latest Xcode
        run: |
          # List available Xcode versions
          echo "ğŸ“± Available Xcode versions:"
          ls -d /Applications/Xcode*.app 2>/dev/null || echo "Checking Xcode paths..."

          # Find the latest Xcode version dynamically
          LATEST_XCODE=$(ls -d /Applications/Xcode*.app 2>/dev/null | sort -V | tail -n 1)

          if [[ -n "$LATEST_XCODE" ]]; then
             sudo xcode-select -s "$LATEST_XCODE/Contents/Developer"
             echo "âœ… Selected latest Xcode: $LATEST_XCODE"
          elif [[ -d "/Applications/Xcode.app" ]]; then
             sudo xcode-select -s /Applications/Xcode.app/Contents/Developer
             echo "âš ï¸ Using default Xcode (specific version not found)"
          else
             echo "âš ï¸ No Xcode found in /Applications, relying on pre-installed environment"
          fi

          echo ""
          echo "ğŸ“± Selected Xcode version:"
          xcodebuild -version
          echo ""
          echo "ğŸ”§ Swift version:"
          swift --version
          echo ""
          echo "ğŸ“ Xcode path:"
          xcode-select -p

      - name: Install Sparkle
        id: sparkle
        run: |
          echo "ğŸ“¥ Installing Sparkle via Homebrew..."
          brew install --cask sparkle

          # Find sign_update tool
          SIGN_UPDATE=""
          for dir in /opt/homebrew/Caskroom/sparkle/*/bin /usr/local/Caskroom/sparkle/*/bin; do
            if [[ -f "$dir/sign_update" ]]; then
              SIGN_UPDATE="$dir/sign_update"
              break
            fi
          done

          if [[ -z "$SIGN_UPDATE" ]]; then
            echo "âŒ ERROR: sign_update tool not found"
            exit 1
          fi

          # Remove quarantine and make executable
          xattr -cr "$SIGN_UPDATE" 2>/dev/null || true
          chmod +x "$SIGN_UPDATE"

          echo "SIGN_UPDATE=$SIGN_UPDATE" >> $GITHUB_ENV
          echo "sign_update=$SIGN_UPDATE" >> $GITHUB_OUTPUT
          echo "âœ… Sparkle installed: $SIGN_UPDATE"

      # =========================================================================
      # BUILD
      # =========================================================================

      - name: Build app
        run: |
          echo "ğŸ”¨ Building ${{ env.APP_NAME }} with Xcode 26.1.1..."

          # Create build directory
          mkdir -p build

          # Build with xcodebuild - simple release build
          # We use ad-hoc signing (-) which gives the app a valid signature
          # structure without requiring Apple Developer ID
          xcodebuild build \
            -project "${{ env.PROJECT }}" \
            -scheme "${{ env.SCHEME }}" \
            -configuration Release \
            -derivedDataPath build/DerivedData \
            -destination "platform=macOS" \
            MACOSX_DEPLOYMENT_TARGET=15.0 \
            ONLY_ACTIVE_ARCH=NO \
            CODE_SIGN_IDENTITY="" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO \
            2>&1 | tee build/build.log

          # Verify build succeeded
          if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
            echo "âŒ Build failed"
            tail -100 build/build.log
            exit 1
          fi

          echo "âœ… Build completed"

      - name: Locate and verify app bundle
        id: app
        run: |
          # Find the built app
          APP_PATH=$(find build/DerivedData -name "${{ env.APP_NAME }}.app" -type d | head -1)

          if [[ -z "$APP_PATH" || ! -d "$APP_PATH" ]]; then
            echo "âŒ ERROR: App bundle not found"
            echo "Contents of build directory:"
            find build -type d -name "*.app" 2>/dev/null || echo "No .app bundles found"
            exit 1
          fi

          echo "APP_PATH=$APP_PATH" >> $GITHUB_ENV
          echo "app_path=$APP_PATH" >> $GITHUB_OUTPUT

          # Verify app structure
          EXECUTABLE="$APP_PATH/Contents/MacOS/${{ env.APP_NAME }}"
          if [[ ! -f "$EXECUTABLE" ]]; then
            echo "âŒ ERROR: Main executable not found"
            ls -la "$APP_PATH/Contents/MacOS/" || true
            exit 1
          fi

          echo "ğŸ“± App bundle: $APP_PATH"
          
          # Extract version info from Info.plist
          APP_INFO_PLIST="$APP_PATH/Contents/Info.plist"
          
          # Build number (CFBundleVersion) - e.g., "12"
          BUILD_NUMBER=$(/usr/libexec/PlistBuddy -c "Print :CFBundleVersion" "$APP_INFO_PLIST")
          
          # Short version (CFBundleShortVersionString) - e.g., "1.3.1"
          SHORT_VERSION=$(/usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" "$APP_INFO_PLIST")
          
          echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
          echo "SHORT_VERSION=$SHORT_VERSION" >> $GITHUB_ENV
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
          echo "short_version=$SHORT_VERSION" >> $GITHUB_OUTPUT
          
          echo "ğŸ“„ Version info:"
          echo "  - Build Number (CFBundleVersion): $BUILD_NUMBER"
          echo "  - Short Version (CFBundleShortVersionString): $SHORT_VERSION"
          echo ""
          echo "ğŸ” Code signature:"
          codesign -dvv "$APP_PATH" 2>&1 || echo "No signature"
          echo ""
          echo "ğŸ“Š Architecture:"
          file "$EXECUTABLE"

      - name: Re-sign app with ad-hoc signature
        run: |
          echo "ğŸ” Applying ad-hoc signature..."

          # Remove any existing signature
          codesign --remove-signature "${{ env.APP_PATH }}" 2>/dev/null || true

          # Sign with ad-hoc signature (-)
          # This creates a valid signature structure without Developer ID
          codesign --force --deep --sign - "${{ env.APP_PATH }}"

          # Verify
          echo ""
          echo "âœ… Signature applied:"
          codesign -dvv "${{ env.APP_PATH }}" 2>&1

      # =========================================================================
      # PACKAGE
      # =========================================================================

      - name: Create release package
        run: |
          mkdir -p release

          # Copy app to release directory
          cp -R "${{ env.APP_PATH }}" "release/${{ env.APP_NAME }}.app"

          # Create README with installation instructions
          cat > release/README.txt << 'EOF'
          ================================================================================
          ${{ env.APP_NAME }} - Installation Instructions
          ================================================================================

          This app is distributed without Apple Developer ID code signing.
          It uses ad-hoc signing, which is safe but requires a one-time approval.

          INSTALLATION (Choose ONE method):

          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚ METHOD 1: Right-Click to Open (Recommended)                                 â”‚
          â”‚                                                                             â”‚
          â”‚ 1. Drag ${{ env.APP_NAME }}.app to /Applications                            â”‚
          â”‚ 2. Right-click (or Control-click) on the app                                â”‚
          â”‚ 3. Select "Open" from the context menu                                      â”‚
          â”‚ 4. Click "Open" in the security dialog                                      â”‚
          â”‚                                                                             â”‚
          â”‚ You only need to do this once. Future launches work normally.               â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚ METHOD 2: Terminal Command                                                  â”‚
          â”‚                                                                             â”‚
          â”‚ If Method 1 doesn't work, open Terminal and run:                            â”‚
          â”‚                                                                             â”‚
          â”‚   xattr -cr /Applications/${{ env.APP_NAME }}.app                           â”‚
          â”‚                                                                             â”‚
          â”‚ This removes the quarantine flag that macOS adds to downloads.              â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

          UPDATES:

          After first launch, the app will automatically check for updates using Sparkle.
          Updates are signed and verified for security.

          SOURCE CODE:

          https://github.com/${{ github.repository }}

          ================================================================================
          EOF

          echo "âœ… Release package prepared"
          ls -la release/

      - name: Create ZIP archive
        id: zip
        run: |
          cd release

          # Create ZIP using ditto (preserves macOS metadata)
          # ZIP contains ONLY the .app bundle - no README.txt
          ZIP_NAME="${{ env.APP_NAME }}.zip"
          ditto -c -k --sequesterRsrc --keepParent "${{ env.APP_NAME }}.app" "$ZIP_NAME"

          # Verify ZIP
          echo "ğŸ“¦ Verifying ZIP archive..."
          unzip -t "$ZIP_NAME" > /dev/null

          # Get file size
          SIZE=$(stat -f%z "$ZIP_NAME")
          echo "FILE_SIZE=$SIZE" >> $GITHUB_ENV
          echo "file_size=$SIZE" >> $GITHUB_OUTPUT

          echo "âœ… ZIP created: $ZIP_NAME ($SIZE bytes)"

      - name: Sign ZIP with Sparkle EdDSA
        id: sparkle_sign
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
        run: |
          cd release

          # Write private key to temp file
          KEY_FILE=$(mktemp)
          echo "$SPARKLE_PRIVATE_KEY" > "$KEY_FILE"

          # Sign the ZIP
          echo "ğŸ” Signing ZIP with Sparkle EdDSA..."
          SIGN_OUTPUT=$("${{ env.SIGN_UPDATE }}" --ed-key-file "$KEY_FILE" "${{ env.APP_NAME }}.zip" 2>&1)
          SIGN_STATUS=$?

          # Securely delete key file
          rm -f "$KEY_FILE"

          if [[ $SIGN_STATUS -ne 0 ]]; then
            echo "âŒ ERROR: Sparkle signing failed"
            echo "$SIGN_OUTPUT"
            exit 1
          fi

          # Extract signature from output
          # sign_update outputs: sparkle:edSignature="..." length="..."
          # or just the raw signature on newer versions
          SIGNATURE=""

          if echo "$SIGN_OUTPUT" | grep -q 'sparkle:edSignature='; then
            SIGNATURE=$(echo "$SIGN_OUTPUT" | sed -n 's/.*sparkle:edSignature="\([^"]*\)".*/\1/p')
          else
            # Fallback: assume output is just the signature
            SIGNATURE=$(echo "$SIGN_OUTPUT" | tr -d '[:space:]')
          fi

          if [[ -z "$SIGNATURE" || ${#SIGNATURE} -lt 10 ]]; then
            echo "âŒ ERROR: Could not extract signature"
            echo "Raw output: $SIGN_OUTPUT"
            exit 1
          fi

          echo "SPARKLE_SIGNATURE=$SIGNATURE" >> $GITHUB_ENV
          echo "signature=$SIGNATURE" >> $GITHUB_OUTPUT
          echo "âœ… Sparkle signature: ${SIGNATURE:0:20}..."

      # =========================================================================
      # APPCAST
      # =========================================================================

      - name: Update appcast.xml
        run: |
          APPCAST_PATH="docs/appcast.xml"

          # Version info from built app
          # - BUILD_NUMBER: integer build version for sparkle:version (e.g., "12")
          # - SHORT_VERSION: marketing version for sparkle:shortVersionString (e.g., "1.3.1")
          echo "ğŸ“‹ Using version info:"
          echo "  - Build Number (sparkle:version): ${{ env.BUILD_NUMBER }}"
          echo "  - Short Version (sparkle:shortVersionString): ${{ env.SHORT_VERSION }}"
          echo "  - File Size: ${{ env.FILE_SIZE }} bytes"
          echo "  - Signature length: ${#SPARKLE_SIGNATURE} chars"

          # Validate signature length (EdDSA base64 is typically ~88 chars)
          SPARKLE_SIGNATURE="${{ env.SPARKLE_SIGNATURE }}"
          if [[ ${#SPARKLE_SIGNATURE} -lt 80 || ${#SPARKLE_SIGNATURE} -gt 100 ]]; then
            echo "âš ï¸ WARNING: Signature length (${#SPARKLE_SIGNATURE}) may be incorrect (expected 80-100 chars)"
          else
            echo "âœ… Signature length looks valid"
          fi

          # 1. Ensure appcast.xml exists
          if [[ ! -f "$APPCAST_PATH" ]]; then
            echo "âš ï¸ No appcast.xml found at $APPCAST_PATH"
            echo "Creating new appcast.xml..."
            mkdir -p docs

            cat > "$APPCAST_PATH" << EOF
          <?xml version="1.0" encoding="utf-8"?>
          <rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" xmlns:dc="http://purl.org/dc/elements/1.1/">
            <channel>
              <title>${{ env.APP_NAME }}</title>
              <link>https://github.com/${{ github.repository }}</link>
              <description>Most recent changes with links to updates.</description>
              <language>en</language>
            </channel>
          </rss>
          EOF
          fi

          # 2. Extract description from <new> section if it exists
          DESCRIPTION_CONTENT=""
          if grep -q "<new>" "$APPCAST_PATH"; then
            echo "ğŸ“ Found <new> section, extracting content for description..."
            # Extract <li> items from <new> section
            DESCRIPTION_CONTENT=$(sed -n '/<new>/,/<\/new>/p' "$APPCAST_PATH" | grep '<li>' | sed 's/^[[:space:]]*//')
            echo "Extracted description items:"
            echo "$DESCRIPTION_CONTENT"
          fi

          # 3. Build release notes HTML
          DOWNLOAD_URL="https://github.com/${{ github.repository }}/releases/download/v${{ env.SHORT_VERSION }}/${{ env.APP_NAME }}.zip"
          RELEASE_DATE=$(date -u +"%a, %d %b %Y %H:%M:%S %z")

          # Create description block
          if [[ -n "$DESCRIPTION_CONTENT" ]]; then
            DESCRIPTION_HTML="<h2>Version ${{ env.SHORT_VERSION }}</h2>
                      <ul>
          $DESCRIPTION_CONTENT
                      </ul>"
          else
            DESCRIPTION_HTML="<h2>Version ${{ env.SHORT_VERSION }}</h2>
                      <p>See release notes on GitHub for details.</p>"
          fi

          # 4. Create temp file with new item
          NEW_ITEM_FILE=$(mktemp)
          cat > "$NEW_ITEM_FILE" << EOF

              <item>
                  <title>Version ${{ env.SHORT_VERSION }}</title>
                  <link>https://foxfollow.github.io/Stone-Clipboarder-Tool/</link>
                  <sparkle:version>${{ env.BUILD_NUMBER }}</sparkle:version>
                  <sparkle:shortVersionString>${{ env.SHORT_VERSION }}</sparkle:shortVersionString>
                  <description
                  ><![CDATA[
                      $DESCRIPTION_HTML
                  ]]></description>
                  <pubDate>$RELEASE_DATE</pubDate>
                  <enclosure
                      url="$DOWNLOAD_URL"
                      sparkle:version="${{ env.BUILD_NUMBER }}"
                      sparkle:shortVersionString="${{ env.SHORT_VERSION }}"
                      sparkle:edSignature="${{ env.SPARKLE_SIGNATURE }}"
                      length="${{ env.FILE_SIZE }}"
                      type="application/octet-stream"
                  />
              </item>
          EOF

          # 5. Remove <new> section and insert new item after </language>
          # First, remove the <new>...</new> section
          sed -i '' '/<new>/,/<\/new>/d' "$APPCAST_PATH"

          # Then insert new item after </language> tag
          awk '
            /<\/language>/ {
              print
              while ((getline line < "'"$NEW_ITEM_FILE"'") > 0) {
                print line
              }
              close("'"$NEW_ITEM_FILE"'")
              next
            }
            { print }
          ' "$APPCAST_PATH" > "${APPCAST_PATH}.new"

          rm -f "$NEW_ITEM_FILE"
          mv "${APPCAST_PATH}.new" "$APPCAST_PATH"

          echo "âœ… Updated appcast.xml with new item"
          echo ""
          echo "ğŸ“„ Updated appcast.xml:"
          cat "$APPCAST_PATH"

      # =========================================================================
      # RELEASE
      # =========================================================================

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ env.VERSION }}
          name: "${{ env.APP_NAME }} v${{ env.VERSION }}"
          draft: false
          prerelease: false
          generate_release_notes: true
          files: release/${{ env.APP_NAME }}.zip
          body: |
            ## ğŸ“¥ Installation

            This app is distributed without Apple Developer ID (free/indie distribution).

            ### Method 1: Right-Click to Open (Easiest)

            1. Download and extract the ZIP
            2. Drag `${{ env.APP_NAME }}.app` to `/Applications`
            3. **Right-click** the app â†’ Select **"Open"**
            4. Click **"Open"** in the dialog

            > You only need to do this once. Future launches work normally.

            ### Method 2: Terminal Command

            ```bash
            xattr -cr /Applications/${{ env.APP_NAME }}.app
            ```

            ---

            ## ğŸ”„ Auto-Updates

            After first launch, the app will automatically check for updates.
            Updates are cryptographically signed for security.

            ---

            **Sparkle Signature:** `${{ env.SPARKLE_SIGNATURE }}`
            **File Size:** ${{ env.FILE_SIZE }} bytes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Commit appcast changes
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Check if appcast was modified
          if git diff --quiet docs/appcast.xml 2>/dev/null; then
            echo "â„¹ï¸ No appcast changes to commit"
            exit 0
          fi

          # Get the default branch
          DEFAULT_BRANCH=$(git remote show origin | grep "HEAD branch" | cut -d: -f2 | tr -d ' ')
          DEFAULT_BRANCH=${DEFAULT_BRANCH:-main}

          # Fetch and checkout default branch
          git fetch origin "$DEFAULT_BRANCH"
          git checkout "$DEFAULT_BRANCH"
          git pull origin "$DEFAULT_BRANCH"

          # Stage and commit
          git add docs/appcast.xml
          git commit -m "chore: update appcast.xml for v${{ env.VERSION }}" -m "[skip ci]"

          # Push with retry
          for i in 1 2 3; do
            if git push origin "$DEFAULT_BRANCH"; then
              echo "âœ… Appcast changes pushed to $DEFAULT_BRANCH"
              exit 0
            fi
            echo "âš ï¸ Push failed, retrying ($i/3)..."
            git pull --rebase origin "$DEFAULT_BRANCH"
            sleep 2
          done

          echo "âŒ Failed to push appcast changes after 3 attempts"
          exit 1

      # =========================================================================
      # SUMMARY
      # =========================================================================

      - name: Build summary
        run: |
          echo ""
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘                           BUILD COMPLETE                                    â•‘"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘ App:        ${{ env.APP_NAME }}                                            "
          echo "â•‘ Version:    ${{ env.VERSION }}                                             "
          echo "â•‘ Size:       ${{ env.FILE_SIZE }} bytes                                     "
          echo "â•‘ Signature:  ${{ env.SPARKLE_SIGNATURE }}                                   "
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘ Release:    https://github.com/${{ github.repository }}/releases/tag/v${{ env.VERSION }}"
          echo "â•‘ Appcast:    https://raw.githubusercontent.com/${{ github.repository }}/main/docs/appcast.xml"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
